---
title: 'Understanding Page and Block Relations in LogSeq (Part 2)'
description: 'A deep dive into implementing and querying page and block relationships in LogSeq using advanced queries'
pubDate: 'Nov 27 2024'
tags: ["logseq", "knowledge-management", "note-taking", "clojure"]
---

In [Part 1](/blog/evaluate-notes-via-relations-pt1), we explored the fundamental concepts of page and block relationships in LogSeq. This continuation delves deeper into implementing these connections through advanced queries, providing practical examples for both simple and complex relationship patterns.

### Quick Recap
Before we dive into advanced queries, let's briefly recall the three primary types of relationships in LogSeq:
- Type A: Block-to-Block relations
- Type B: Block-to-Page relations
- Type C: Page-to-Page relations

### First-Degree Relations

First-degree relations represent direct connections between elements in LogSeq. We'll examine each type using Clojure query syntax, focusing on the predicates that define these relationships.

#### Block-to-Block Relations (Type A)

1. **Linear Relations**: Find blocks with ancestor-descendant relationships
```clojure
[?descendant :block/parent ?parent]
[?parent :block/parent ?ancestor]

;; Note: This query traverses two levels of hierarchy
;; For deeper nesting, additional :block/parent predicates would be needed
```

2. **Content References**: ;; Find blocks that reference other blocks in their content
```clojure
[?a :block/refs ?b]
```

#### Block-to-Page Relations (Type B)

1. **Containment Relations**: Find blocks contained within specific pages
```clojure
[?block :block/page ?page]
[?page :block/name ?pageName]
```

2. **Metadata References**: Find blocks that reference pages in their metadata
```clojure
[?page :block/name ?pageName]
(property ?block :tags ?pageName)

;; Note: This predicate is case-sensitive and doesn't support uppercase letters
```

3. **Content References**: Find blocks that reference pages in their content
```clojure
[?block :block/refs ?page]
[(missing? $ ?page :block/page)]
```

#### Page-to-Page Relations (Type C)

1. **Linear Relations**: Find pages with namespace relationships
```clojure
[?descendant :block/namespace ?parent]
[?parent :block/namespace ?ancestor]
```

2. **Metadata References**: Find pages that reference other pages in their metadata
```clojure
[?a :block/tags ?b]
```

### Second-Degree Relations

Second-degree relations combine two first-degree relations to establish indirect connections. While there are 29 possible combinations, we'll explore some common patterns that demonstrate how to compose more complex queries.

#### Type A → Type A

##### Example 1-1
combine method A.1 and A.2  
predicate: is 'Block A' lineal related to 'Block B' as ancestor-descendant AND 'Block A' mention 'Block C' in content  
conclusion: 'Block B' is related to 'Block C'
```clojure
[?descendant :block/parent ?parent]
[?parent :block/parent ?ancestor]
[?ancestor :block/refs ?blockC]
```

#### Type A → Type B

##### Example 2-1
combine method A.1 and B.3  
predicate: is 'Block A' lineal related to 'Block B' as parent-child and 'Block A' mention 'Page C' in content  
thus, 'Block B' is related to 'Page C'
```clojure
[?child :block/parent ?parent]
[?parent :block/refs ?page]
[(missing? $ ?page :block/page)]
```

##### Example 2-2
combine method A.2 and B.1  
predicate: is 'Block A' lineal related to 'Page B' and 'Block A' mention 'Block C' in content  
conclusion: 'Page B' is related to 'Block C'

```clojure
[?blockA :block/page ?page]
[?page :block/name ?pageName]
[?blockA :block/refs ?blockC]
```

#### Type B → Type B

##### Example 3-1
combine method B.3 and B.2  
predicate: is 'Block A' mention 'Page B' in content and 'Block A' mention 'Page C' in metadata  
conclusion: 'Page B' is related to 'Page C'
```clojure
[?block :block/path-refs ?pageB]
[(missing? $ ?pageB :block/page)]
[?pageC :block/name ?pageName]
(property ?block :tags ?pageName)
```

##### Example 3-2
ombine method B.3 and B.3  
redicate: is 'Block A' mention 'Page B' in content and 'Block A' mention 'Page C' in content  
onclusion: 'Page B' is related to 'Page C'
```clojure
[?block :block/refs ?pageA]
[?block :block/refs ?pageB]
[(missing? $ ?pageA :block/page)]
```

#### Type B → Type C

##### Example 4-1
combine method B.1 and C.2  
predicate: is 'Block A' lineal related to 'Page B' and 'Page B' mention 'Page C' in metadata  
conclusion: 'Block A' is related to 'Page C'
```clojure
[?block :block/page ?pageB]
[?pageB :block/name ?pageName]
[?pageB :block/tags ?pageC]
```

#### Type C → Type C

##### Example 5-1
combine method C.2 and C.2  
predicate: is 'Page A' mention 'Page B' in metadata and 'Page B' mention 'Page C' in metadata  
conclusion: 'Page A' is related to 'Page C'

```clojure
[?a :block/tags ?b]
[?b :block/tags ?c]
```

##### Example 5-2
combine method C.1 and C.2  
predicate: is 'Page A' lineal related to 'Page B' as ancestor-descendant and 'Page A' mention 'Page C' in metadata  
conclusion: 'Page B' is related to 'Page C'

Note: alias is only used when the page is using an alias

```clojure
[?descendant :block/namespace ?parent]
[?parent :block/namespace ?ancestor]
[?ancestor :block/alias ?actualPage]
[?actualPage :block/tags ?pageC]
```

### Important Considerations

When working with these queries, keep in mind:

1. **Alias Handling**: When pages use aliases, include additional predicates:
```clojure
[?page :block/alias ?actualPage]
```

2. **Hierarchy Depth**: Deep hierarchies require additional predicates. Currently, LogSeq doesn't support recursive predicates, so you'll need to explicitly specify each level.

3. **Logical Consistency**: While predicate order doesn't affect query execution, maintaining logical relationship flow still matters. For example, ancestor pages shouldn't typically related to descendant metadata.

### Future Development Roadmap

To make these relationships more actionable, we're planning several enhancements:

1. **Relationship Weighting System**
   - Assign different weights based on relation types
   - Consider frequency and recency of connections
   - Weight direct references higher than indirect ones

2. **Page Evaluation Metrics**
   - Centrality measures for identifying key pages
   - Connection density analysis
   - Topic cluster identification
   - Temporal relationship patterns

3. **Query Pattern Library**
   - Predefined queries for common relationship patterns
   - Custom rule definitions for complex relationships
   - Performance-optimized query templates

These developments aim to help users better understand and utilize the knowledge connections within their LogSeq graphs.