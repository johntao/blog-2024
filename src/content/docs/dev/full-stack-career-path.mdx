---
title: "What's Up With \"Full-Stack Developer\"?"
description: 'Personal insights on the evolution of a full-stack developer career, discussing the relative importance of UI, DX, and core development principles'
pubDate: 'Feb 10 2025'
tags: ["web-development", "career", "full-stack", "software-architecture"]
---

I've identified as a full-stack web developer for years, starting with my first job where I dove deep into [SQL](https://en.wikipedia.org/wiki/SQL), [ASP.NET](https://dotnet.microsoft.com/en-us/apps/aspnet), [jQuery](https://jquery.com/), and [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript). My journey with jQuery began in 2016 (yes, a bit late), and it was my first glimpse into dynamic web frontends. Through my involvement with the [VirtoCommerce](https://virtocommerce.com/) project, I also gained exposure to [AngularJS](https://angularjs.org/) and [Shopify's Liquid](https://shopify.github.io/liquid/) template system.

In 2020, I shifted to a backend developer role, which introduced me to [Linux](https://www.linux.org/), [Docker](https://www.docker.com/), [Message Queues](https://en.wikipedia.org/wiki/Message_queue), and [DevOps](https://en.wikipedia.org/wiki/DevOps). Working with high-throughput systems taught me the critical importance of robust backend architecture -- a revelation that shaped my understanding of [system design](https://en.wikipedia.org/wiki/Software_architecture).

By 2022, I returned to full-stack development, this time leading web development initiatives. I introduced modern technologies like [React](https://react.dev/), [TypeScript](https://www.typescriptlang.org/), [React-Admin](https://marmelab.com/react-admin/), [React Query](https://tanstack.com/query/latest), [SignalR](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction), and [EF Core](https://learn.microsoft.com/en-us/ef/core/) to the team. This experience taught me several valuable lessons:

- Effective communication is crucial when adopting new frameworks
- While frameworks are replaceable, core domain knowledge is permanent (as emphasized in ["Clean Architecture"](https://g.co/kgs/UWNtzff))
- A framework's community and resources significantly impact its viability
  - The size of the community matters
  - Consider whether the framework is popular enough for [generative AI](https://en.wikipedia.org/wiki/Generative_artificial_intelligence) tools to provide meaningful assistance
- User experience is critical, but UI implementation is somewhat inessential

My perspective on UI's importance has crystallized over recent months:
- While UI creates the first impression, content remains the core value
- Using the [Kano Model](https://en.wikipedia.org/wiki/Kano_model) as reference, UI elements are often "exciters" while content represents "must-haves"
  - With limited resources, prioritize completing all must-have features to ensure basic quality
  - This aligns with [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) and the principle that ["Premature Optimization Is The Root Of All Evil"](https://wiki.c2.com/?PrematureOptimization)
  - Additionally, developing applications without concrete content, context, and requirements violates YAGNI
- Full-stack developers often struggle to efficiently create polished UIs
  - This work is better suited for dedicated designers or frontend specialists

I've noticed that [CI/CD](https://en.wikipedia.org/wiki/CI/CD) and [Developer Experience (DX)](https://en.wikipedia.org/wiki/Developer_experience) share similar characteristics:
- Source code represents the core content
- Features are closer to must-haves, while DX improvements are more like exciters
- Achieving excellence in DX requires dedicated effort and commitment

From my experience, here are some guidelines for selecting the right tools:
- Commit to one framework or design system at a time
  - Success comes from understanding requirements and comprehending the primitives of the chosen tool (good primitives also lead to success)
- Identifying requirements early helps avoid switching tools
  - Switching tools mid-project is costly
    - Consider the cost of: workarounds, source code modifications, paid features, or finding a new tool
  - This insight helps determine whether to choose a high-level abstraction tool or a low-level one
    - High-level abstraction tools offer ease of use but limited customization
    - Sometimes, simpler tools with good primitives, combined with generative AI, provide better results
- While libraries are more modular and replaceable
  - Stick to one at a time to maintain lean dependencies and consistency

These insights stem from various experiences:
- Developing a custom [ERP](https://en.wikipedia.org/wiki/Enterprise_resource_planning) for a small business instead of adopting existing solutions
- Exploring [headless](https://en.wikipedia.org/wiki/Headless_software) and framework-agnostic design while building a proof-of-concept
- Creating a personal productivity app without established usage patterns
- Over-customizing a default website theme instead of starting with a well-designed template

While these experiences have made me better equipped for similar challenges, mastering UI, DX, and product development remains an ongoing journey. Some call it "learning development the hard way." Though I don't have all the answers, "[failing fast](https://en.wikipedia.org/wiki/Fail-fast)" seems to be a viable approach.

For full-stack developers, I believe the key is to continue exploring and experimenting with short iterations. This process often leads to discovering your niche and strengths. Here are some opportunities I'm considering:
- Creating a data converter between [LogSeq](https://logseq.com/) and [LibreOffice](https://www.libreoffice.org/) to leverage LibreOffice's table editing capabilities
- Integrating [Astro](https://astro.build/) frontend with headless backends (e.g., LogSeq, [WordPress](https://wordpress.org/), [Odoo](https://www.odoo.com/))
- Installing a local [LLM](https://en.wikipedia.org/wiki/Large_language_model) for note analysis
- Using [n8n](https://n8n.io/) to introduce new interfaces and streamline the workflows mentioned above

Hopefully, one of these paths leads to a fulfilling "full-stack developer" career ðŸ¤“

